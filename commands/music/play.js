const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');
const musicIcons = require('../../UI/icons/musicicons');
const SpotifyWebApi = require('spotify-web-api-node');
const { getData } = require('spotify-url-info')(fetch);
const config = require('../../config.js');

const spotifyApi = new SpotifyWebApi({
    clientId: config.spotifyClientId,
    clientSecret: config.spotifyClientSecret,
});

module.exports = {
    data: new SlashCommandBuilder()
        .setName('play')
        .setDescription('üéµ Ph√°t nh·∫°c - All-in-one music command')
        .addSubcommand(subcommand =>
            subcommand
                .setName('song')
                .setDescription('Ph√°t b√†i h√°t ho·∫∑c playlist')
                .addStringOption(option =>
                    option.setName('query')
                        .setDescription('T√™n b√†i h√°t, URL YouTube/Spotify')
                        .setRequired(true)))
        .addSubcommand(subcommand =>
            subcommand
                .setName('pause')
                .setDescription('T·∫°m d·ª´ng nh·∫°c'))
        .addSubcommand(subcommand =>
            subcommand
                .setName('resume')
                .setDescription('Ti·∫øp t·ª•c ph√°t nh·∫°c'))
        .addSubcommand(subcommand =>
            subcommand
                .setName('skip')
                .setDescription('B·ªè qua b√†i hi·ªán t·∫°i'))
        .addSubcommand(subcommand =>
            subcommand
                .setName('stop')
                .setDescription('D·ª´ng nh·∫°c v√† x√≥a queue'))
        .addSubcommand(subcommand =>
            subcommand
                .setName('queue')
                .setDescription('Xem h√†ng ƒë·ª£i nh·∫°c'))
        .addSubcommand(subcommand =>
            subcommand
                .setName('nowplaying')
                .setDescription('Xem b√†i ƒëang ph√°t'))
        .addSubcommand(subcommand =>
            subcommand
                .setName('volume')
                .setDescription('ƒêi·ªÅu ch·ªânh √¢m l∆∞·ª£ng')
                .addIntegerOption(option =>
                    option.setName('level')
                        .setDescription('M·ª©c √¢m l∆∞·ª£ng 0-100')
                        .setRequired(true)
                        .setMinValue(0)
                        .setMaxValue(100)))
        .addSubcommand(subcommand =>
            subcommand
                .setName('shuffle')
                .setDescription('Tr·ªôn ng·∫´u nhi√™n h√†ng ƒë·ª£i'))
        .addSubcommand(subcommand =>
            subcommand
                .setName('loop')
                .setDescription('Ch·∫ø ƒë·ªô l·∫∑p nh·∫°c')
                .addStringOption(option =>
                    option.setName('mode')
                        .setDescription('Ch·ªçn ch·∫ø ƒë·ªô l·∫∑p')
                        .setRequired(true)
                        .addChoices(
                            { name: 'T·∫Øt l·∫∑p', value: 'none' },
                            { name: 'L·∫∑p b√†i hi·ªán t·∫°i', value: 'track' },
                            { name: 'L·∫∑p h√†ng ƒë·ª£i', value: 'queue' }
                        ))),

    async execute(interaction) {
        try {
            await interaction.deferReply();
            const subcommand = interaction.options.getSubcommand();
            const user = interaction.user;
            const member = interaction.member;
            const { channel } = member.voice;
            const client = interaction.client;
            const guildId = interaction.guild.id;

            // Helper functions
            const checkVoiceChannel = async () => {
                if (!channel) {
                    const errorEmbed = new EmbedBuilder()
                        .setColor('#FF0000')
                        .setDescription('‚ùå B·∫°n ph·∫£i ·ªü trong voice channel ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y.');
                    
                    const reply = await interaction.editReply({ embeds: [errorEmbed] });
                    setTimeout(() => reply.delete().catch(() => {}), 3000);
                    return false;
                }
                return true;
            };

            const getOrCreatePlayer = async () => {
                let player = client.riffy.players.get(guildId);
                
                if (!player) {
                    try {
                        player = await client.riffy.createConnection({
                            guildId,
                            voiceChannel: channel.id,
                            textChannel: interaction.channel.id,
                            deaf: true
                        });
                    } catch (error) {
                        console.error('Error creating player:', error);
                        await interaction.editReply({ content: '‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn voice channel.' });
                        return null;
                    }
                }
                return player;
            };

            const checkPlayerExists = async () => {
                const player = client.riffy.players.get(guildId);
                if (!player) {
                    const reply = await interaction.editReply({ content: '‚ùå Kh√¥ng c√≥ nh·∫°c ƒëang ph√°t. D√πng `/play song` ƒë·ªÉ b·∫Øt ƒë·∫ßu!' });
                    setTimeout(() => reply.delete().catch(() => {}), 3000);
                    return false;
                }
                return player;
            };

            // Handle subcommands
            switch (subcommand) {
                case 'song': {
                    if (!await checkVoiceChannel()) return;
                    
                    const query = interaction.options.getString('query');
                    let player = await getOrCreatePlayer();
                    if (!player) return;

            // X·ª≠ l√Ω Spotify links
            if (query.includes('spotify.com')) {
                try {
                    const spotifyData = await getData(query);
                    const token = await spotifyApi.clientCredentialsGrant();
                    spotifyApi.setAccessToken(token.body.access_token);
            
                    let trackList = [];
            
                    if (spotifyData.type === 'track') {
                        const searchQuery = `${spotifyData.name} - ${spotifyData.artists.map(a => a.name).join(', ')}`;
                        trackList.push(searchQuery);
                    } else if (spotifyData.type === 'playlist') {
                        const playlistId = query.split('/playlist/')[1].split('?')[0];
                        let offset = 0;
                        const limit = 100;
                        let fetched = [];
            
                        do {
                            const data = await spotifyApi.getPlaylistTracks(playlistId, { limit, offset });
                            fetched = data.body.items.filter(item => item.track).map(item =>
                                `${item.track.name} - ${item.track.artists.map(a => a.name).join(', ')}`
                            );
                            trackList.push(...fetched);
                            offset += limit;
                        } while (fetched.length === limit);
                    }

                    if (trackList.length === 0) {
                        await interaction.editReply({ 
                            content: "‚ùå Kh√¥ng t√¨m th·∫•y track n√†o trong Spotify link n√†y." 
                        });
                        return;
                    }
            
                    let added = 0;
                    for (const trackQuery of trackList) {
                        const result = await client.riffy.resolve({ query: trackQuery, requester: user });
                        if (result && result.tracks && result.tracks.length > 0) {
                            const resolvedTrack = result.tracks[0];
                            resolvedTrack.requester = {
                                id: user.id,
                                username: user.username,
                                avatarURL: user.displayAvatarURL()
                            };
                            player.queue.add(resolvedTrack);
                            added++;
                        }
                    }
            
                    const embed = new EmbedBuilder()
                        .setColor('#1DB954')
                        .setTitle(`üéµ Spotify ${spotifyData.type === 'track' ? 'Track' : 'Playlist'} ƒê√£ Th√™m`)
                        .setDescription(`‚úÖ ƒê√£ th√™m ${added} track(s) t·ª´ Spotify v√†o h√†ng ƒë·ª£i.`)
                        .setFooter({ text: `Y√™u c·∫ßu b·ªüi: ${user.username}`, iconURL: user.displayAvatarURL() });
            
                    const reply = await interaction.editReply({ embeds: [embed] });
                    setTimeout(() => reply.delete().catch(() => {}), 3000);
            
                    if (!player.playing && !player.paused) player.play();
                } catch (spotifyError) {
                    console.error('Spotify error:', spotifyError);
                    const errorEmbed = new EmbedBuilder()
                        .setColor('#FF0000')
                        .setTitle('‚ùå L·ªói Spotify')
                        .setDescription('Kh√¥ng th·ªÉ x·ª≠ l√Ω Spotify link. Vui l√≤ng ki·ªÉm tra th√¥ng tin Spotify ho·∫∑c th·ª≠ link kh√°c.')
                        .setFooter({ text: 'PHUCX Music Bot', iconURL: musicIcons.alertIcon });
                    
                    const reply = await interaction.editReply({ embeds: [errorEmbed] });
                    setTimeout(() => reply.delete().catch(() => {}), 5000);
                    return;
                }
            }  
            // X·ª≠ l√Ω YouTube links
            else if (query.includes('youtube.com') || query.includes('youtu.be')) {
                let isPlaylist = query.includes('list=');
                let isMix = query.includes('list=RD');
        
                if (isMix) {
                    const mixEmbed = new EmbedBuilder()
                        .setColor('#FF0000')
                        .setTitle('‚ùå N·ªôi Dung Kh√¥ng H·ªó Tr·ª£')
                        .setDescription('YouTube mixes hi·ªán t·∫°i kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£.\nVui l√≤ng s·ª≠ d·ª•ng track ho·∫∑c playlist kh√°c.')
                        .setFooter({ text: 'PHUCX Music Bot', iconURL: musicIcons.alertIcon });
                
                    const reply = await interaction.editReply({ embeds: [mixEmbed] });
                    setTimeout(() => reply.delete().catch(() => {}), 3000);
                    return;
                }
                
                const resolve = await client.riffy.resolve({ query, requester: user });
                if (!resolve || !resolve.tracks || resolve.tracks.length === 0) {
                    const noResultsEmbed = new EmbedBuilder()
                        .setColor('#FF0000')
                        .setTitle('‚ùå Kh√¥ng T√¨m Th·∫•y K·∫øt Qu·∫£')
                        .setDescription('Kh√¥ng th·ªÉ t√¨m th·∫•y track n√†o ph√π h·ª£p v·ªõi truy v·∫•n c·ªßa b·∫°n.\nTh·ª≠ s·ª≠a ƒë·ªïi t√¨m ki·∫øm.')
                        .setFooter({ text: 'PHUCX Music Bot', iconURL: musicIcons.alertIcon });
                
                    const reply = await interaction.editReply({ embeds: [noResultsEmbed] });
                    setTimeout(() => reply.delete().catch(() => {}), 3000);
                    return;
                }
                
                if (isPlaylist) {
                    for (const track of resolve.tracks) {
                        track.requester = {
                            id: user.id,
                            username: user.username,
                            avatarURL: user.displayAvatarURL()
                        };
                        player.queue.add(track);
                    }
        
                    const embed = new EmbedBuilder()
                        .setColor('#DC92FF')
                        .setAuthor({ name: 'Playlist ƒê√£ Th√™m', iconURL: musicIcons.correctIcon })
                        .setFooter({ text: `Y√™u c·∫ßu b·ªüi: ${user.username}`, iconURL: user.displayAvatarURL() })
                        .setDescription(`‚úÖ ƒê√£ th√™m **PlayList** tracks v√†o h√†ng ƒë·ª£i.`);
        
                    const reply = await interaction.editReply({ 
                        embeds: [embed],
                        files: [{ attachment: musicIcons.wrongIconPath, name: 'wrong.gif' }]
                    });
                    setTimeout(() => reply.delete().catch(() => {}), 3000);
                } else {
                    const track = resolve.tracks[0];
                    track.requester = {
                        id: user.id,
                        username: user.username,
                        avatarURL: user.displayAvatarURL()
                    };
                    player.queue.add(track);
        
                    const embed = new EmbedBuilder()
                        .setColor('#DC92FF')
                        .setAuthor({ name: 'Track ƒê√£ Th√™m', iconURL: musicIcons.correctIcon })
                        .setFooter({ text: `Y√™u c·∫ßu b·ªüi: ${user.username}`, iconURL: user.displayAvatarURL() })
                        .setDescription(`üéµ ƒê√£ th√™m **${track.info.title}** v√†o h√†ng ƒë·ª£i.`);
        
                    const reply = await interaction.editReply({ 
                        embeds: [embed],
                        files: [{ attachment: musicIcons.wrongIconPath, name: 'wrong.gif' }]
                    });
                    setTimeout(() => reply.delete().catch(() => {}), 3000);
                }
        
                if (!player.playing && !player.paused) player.play();
            }
            // X·ª≠ l√Ω t√¨m ki·∫øm th√¥ng th∆∞·ªùng
            else {
                const resolve = await client.riffy.resolve({ query, requester: user });
                
                if (!resolve || !resolve.tracks || resolve.tracks.length === 0) {
                    const noResultsEmbed = new EmbedBuilder()
                        .setColor('#FF0000')
                        .setTitle('‚ùå Kh√¥ng T√¨m Th·∫•y K·∫øt Qu·∫£')
                        .setDescription('Kh√¥ng th·ªÉ t√¨m th·∫•y track n√†o ph√π h·ª£p v·ªõi truy v·∫•n c·ªßa b·∫°n.\nTh·ª≠ s·ª≠a ƒë·ªïi t√¨m ki·∫øm.')
                        .setFooter({ text: 'PHUCX Music Bot', iconURL: musicIcons.alertIcon });
                
                    const reply = await interaction.editReply({ embeds: [noResultsEmbed] });
                    setTimeout(() => reply.delete().catch(() => {}), 3000);
                    return;
                }

                const track = resolve.tracks[0];
                track.requester = {
                    id: user.id,
                    username: user.username,
                    avatarURL: user.displayAvatarURL()
                };
                player.queue.add(track);

                const embed = new EmbedBuilder()
                    .setColor('#DC92FF')
                    .setAuthor({ name: 'Track ƒê√£ Th√™m', iconURL: musicIcons.correctIcon })
                    .setFooter({ text: `Y√™u c·∫ßu b·ªüi: ${user.username}`, iconURL: user.displayAvatarURL() })
                    .setDescription(`üéµ ƒê√£ th√™m **${track.info.title}** v√†o h√†ng ƒë·ª£i.`);

                const reply = await interaction.editReply({ 
                    embeds: [embed],
                    files: [{ attachment: musicIcons.wrongIconPath, name: 'wrong.gif' }]
                });
                setTimeout(() => reply.delete().catch(() => {}), 3000);

                if (!player.playing && !player.paused) player.play();
            }
                    break;
                }

                case 'pause': {
                    const player = await checkPlayerExists();
                    if (!player) return;
                    
                    if (player.paused) {
                        const reply = await interaction.editReply({ content: '‚è∏Ô∏è Nh·∫°c ƒë√£ ƒë∆∞·ª£c t·∫°m d·ª´ng r·ªìi.' });
                        setTimeout(() => reply.delete().catch(() => {}), 3000);
                        return;
                    }
                    
                    player.pause(true);
                    const reply = await interaction.editReply({ content: '‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng nh·∫°c.' });
                    setTimeout(() => reply.delete().catch(() => {}), 3000);
                    break;
                }

                case 'resume': {
                    const player = await checkPlayerExists();
                    if (!player) return;
                    
                    if (!player.paused) {
                        const reply = await interaction.editReply({ content: '‚ñ∂Ô∏è Nh·∫°c ch∆∞a b·ªã t·∫°m d·ª´ng.' });
                        setTimeout(() => reply.delete().catch(() => {}), 3000);
                        return;
                    }
                    
                    player.pause(false);
                    const reply = await interaction.editReply({ content: '‚ñ∂Ô∏è Ti·∫øp t·ª•c ph√°t nh·∫°c.' });
                    setTimeout(() => reply.delete().catch(() => {}), 3000);
                    break;
                }

                case 'skip': {
                    const player = await checkPlayerExists();
                    if (!player) return;
                    
                    if (player.queue.length === 0) {
                        const reply = await interaction.editReply({ content: '‚è≠Ô∏è Kh√¥ng c√≥ b√†i ti·∫øp theo ƒë·ªÉ b·ªè qua.' });
                        setTimeout(() => reply.delete().catch(() => {}), 3000);
                        return;
                    }
                    
                    const currentTrack = player.current?.info?.title || 'B√†i h√°t kh√¥ng x√°c ƒë·ªãnh';
                    player.stop();
                    const reply = await interaction.editReply({ content: `‚è≠Ô∏è ƒê√£ b·ªè qua: **${currentTrack}**` });
                    setTimeout(() => reply.delete().catch(() => {}), 3000);
                    break;
                }

                case 'stop': {
                    const player = await checkPlayerExists();
                    if (!player) return;
                    
                    player.destroy();
                    const reply = await interaction.editReply({ content: '‚èπÔ∏è ƒê√£ d·ª´ng nh·∫°c v√† x√≥a h√†ng ƒë·ª£i.' });
                    setTimeout(() => reply.delete().catch(() => {}), 3000);
                    break;
                }

                case 'queue': {
                    const player = await checkPlayerExists();
                    if (!player) return;
                    
                    const queue = player.queue;
                    if (!queue || queue.length === 0) {
                        const reply = await interaction.editReply({ content: 'üì≠ H√†ng ƒë·ª£i ƒëang tr·ªëng.' });
                        setTimeout(() => reply.delete().catch(() => {}), 3000);
                        return;
                    }
                    
                    const maxDisplay = 10;
                    const displayQueue = queue.slice(0, maxDisplay);
                    const formattedQueue = displayQueue.map((track, i) => {
                        const requester = track.requester?.username || 'Kh√¥ng x√°c ƒë·ªãnh';
                        return `${i + 1}. **${track.info.title}**\n   üë§ ${requester}`;
                    }).join('\n\n');
                    
                    const queueEmbed = new EmbedBuilder()
                        .setColor('#DC92FF')
                        .setTitle('üé∂ H√†ng ƒê·ª£i Hi·ªán T·∫°i')
                        .setDescription(formattedQueue)
                        .setFooter({ 
                            text: queue.length > maxDisplay 
                                ? `Hi·ªÉn th·ªã ${maxDisplay}/${queue.length} b√†i h√°t` 
                                : `T·ªïng c·ªông ${queue.length} b√†i h√°t`
                        });
                    
                    await interaction.editReply({ embeds: [queueEmbed] });
                    break;
                }

                case 'nowplaying': {
                    const player = await checkPlayerExists();
                    if (!player) return;
                    
                    const currentTrack = player.current;
                    if (!currentTrack) {
                        const reply = await interaction.editReply({ content: '‚ùå Kh√¥ng c√≥ b√†i h√°t ƒëang ph√°t.' });
                        setTimeout(() => reply.delete().catch(() => {}), 3000);
                        return;
                    }
                    
                    const npEmbed = new EmbedBuilder()
                        .setColor('#00D4FF')
                        .setTitle('üéµ ƒêang Ph√°t')
                        .setDescription(`**${currentTrack.info.title}**`)
                        .addFields(
                            { name: 'üé§ T√°c gi·∫£', value: `\`${currentTrack.info.author || 'Kh√¥ng x√°c ƒë·ªãnh'}\``, inline: true },
                            { name: 'üë§ Y√™u c·∫ßu b·ªüi', value: `<@${currentTrack.requester?.id || user.id}>`, inline: true }
                        );
                    
                    if (currentTrack.info.artwork) {
                        npEmbed.setThumbnail(currentTrack.info.artwork);
                    }
                    
                    const reply = await interaction.editReply({ embeds: [npEmbed] });
                    setTimeout(() => reply.delete().catch(() => {}), 10000);
                    break;
                }

                case 'volume': {
                    const player = await checkPlayerExists();
                    if (!player) return;
                    
                    const volume = interaction.options.getInteger('level');
                    player.setVolume(volume);
                    const reply = await interaction.editReply({ content: `üîä √Çm l∆∞·ª£ng ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t th√†nh **${volume}%**` });
                    setTimeout(() => reply.delete().catch(() => {}), 3000);
                    break;
                }

                case 'shuffle': {
                    const player = await checkPlayerExists();
                    if (!player) return;
                    
                    if (player.queue.length < 2) {
                        const reply = await interaction.editReply({ content: '‚ùå C·∫ßn √≠t nh·∫•t 2 b√†i h√°t trong h√†ng ƒë·ª£i ƒë·ªÉ tr·ªôn.' });
                        setTimeout(() => reply.delete().catch(() => {}), 3000);
                        return;
                    }
                    
                    player.queue.shuffle();
                    const reply = await interaction.editReply({ content: 'üîÄ ƒê√£ tr·ªôn ng·∫´u nhi√™n h√†ng ƒë·ª£i!' });
                    setTimeout(() => reply.delete().catch(() => {}), 3000);
                    break;
                }

                case 'loop': {
                    const player = await checkPlayerExists();
                    if (!player) return;
                    
                    const mode = interaction.options.getString('mode');
                    
                    try {
                        player.setLoop(mode);
                        const modeText = mode === 'none' ? 'T·∫Øt l·∫∑p' : 
                                        mode === 'track' ? 'L·∫∑p b√†i hi·ªán t·∫°i' : 'L·∫∑p h√†ng ƒë·ª£i';
                        const reply = await interaction.editReply({ content: `üîÅ Ch·∫ø ƒë·ªô l·∫∑p: **${modeText}**` });
                        setTimeout(() => reply.delete().catch(() => {}), 3000);
                    } catch (error) {
                        console.error('Error setting loop mode:', error);
                        const reply = await interaction.editReply({ content: '‚ùå Kh√¥ng th·ªÉ thi·∫øt l·∫≠p ch·∫ø ƒë·ªô l·∫∑p.' });
                        setTimeout(() => reply.delete().catch(() => {}), 3000);
                    }
                    break;
                }
            }
        } catch (error) {
            console.error('Error in play command:', error);
        
            const errorEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå ƒê√£ X·∫£y Ra L·ªói')
                .setDescription('C√≥ g√¨ ƒë√≥ sai khi x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n.\n\n**M·∫πo:**\n- Th·ª≠ thay ƒë·ªïi Lavalink trong config.\n- Ki·ªÉm tra URL track/playlist.')
                .setFooter({ text: 'PHUCX Music Bot', iconURL: musicIcons.alertIcon })
                .setTimestamp();
        
            const reply = await interaction.editReply({ embeds: [errorEmbed] });
        
            setTimeout(() => {
                reply.delete().catch(() => {});
            }, 6000);
        }
    }
};
